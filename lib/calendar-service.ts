import { 
  collection, 
  doc, 
  addDoc, 
  updateDoc, 
  deleteDoc, 
  getDocs, 
  getDoc, 
  query, 
  where, 
  orderBy, 
  limit,
  serverTimestamp,
  Timestamp 
} from 'firebase/firestore';
import { db } from './firebase';
import { ActivityService } from './activity-service';
import { NotificationService } from './notification-service';

// Dynamic imports to avoid circular dependencies
let ReportService: any;
let ReportTemplateService: any;

// Lazy load services when needed
const getReportService = async () => {
  if (!ReportService) {
    const importedModule = await import('./report-service');
    ReportService = importedModule.ReportService;
  }
  return ReportService;
};

const getReportTemplateService = async () => {
  if (!ReportTemplateService) {
    const importedModule = await import('./report-template-service');
    ReportTemplateService = importedModule.ReportTemplateService;
  }
  return ReportTemplateService;
};

export interface CalendarEvent {
  id: string;
  title: string;
  description?: string;
  start: Date;
  end?: Date;
  allDay?: boolean;
  type: 'meeting' | 'deadline' | 'training' | 'review' | 'reminder' | 'report' | 'other';
  status: 'scheduled' | 'completed' | 'cancelled' | 'pending';
  priority: 'low' | 'medium' | 'high' | 'urgent';
  visibility?: 'public' | 'private' | 'restricted';
  location?: string;
  attendees?: string[];
  createdBy: string;
  workspaceId: string;
  departmentId?: string;
  teamId?: string;
  relatedId?: string; // Related report, task, or project ID
  isRecurring?: boolean;
  recurringPattern?: RecurringPattern;
  notes?: string;
  reminders?: EventReminder[];
  tags?: string[];
  attachments?: EventAttachment[];
  createdAt: Date;
  updatedAt: Date;
}

export interface RecurringPattern {
  frequency: 'daily' | 'weekly' | 'monthly' | 'yearly';
  interval: number; // Every X days/weeks/months/years
  daysOfWeek?: number[]; // For weekly: 0=Sunday, 1=Monday, etc.
  dayOfMonth?: number; // For monthly
  endDate?: Date;
  occurrences?: number; // Number of occurrences
}

export interface EventReminder {
  time: number; // Minutes before event
  type: 'email' | 'notification' | 'both';
  sent?: boolean;
}

export interface EventAttachment {
  id: string;
  name: string;
  url: string;
  type: string;
  size: number;
  uploadedBy: string;
  uploadedAt: Date;
}

export interface CalendarFilters {
  types: string[];
  status: string[];
  departments: string[];
  teams: string[];
  dateRange: {
    start: Date;
    end: Date;
  };
  priority: string[];
  searchTerm: string;
}

export interface ReportDeadline extends CalendarEvent {
  templateId: string;
  templateName: string;
  requiredDepartments?: string[];
  autoGenerated: boolean;
  submissionCount?: number;
  completionRate?: number;
}

export class CalendarService {
  private static readonly COLLECTION_NAME = 'calendar_events';

  private static getEventsCollection(workspaceId: string) {
    return collection(db, 'workspaces', workspaceId, this.COLLECTION_NAME);
  }

  private static getEventDoc(workspaceId: string, eventId: string) {
    return doc(db, 'workspaces', workspaceId, this.COLLECTION_NAME, eventId);
  }

  // Helper function to remove undefined values for Firestore
  private static cleanEventData(data: any): any {
    const cleaned: any = {};
    Object.keys(data).forEach(key => {
      if (data[key] !== undefined) {
        cleaned[key] = data[key];
      }
    });
    return cleaned;
  }

  // Create a new calendar event
  static async createEvent(
    workspaceId: string,
    eventData: Omit<CalendarEvent, 'id' | 'createdAt' | 'updatedAt'>,
    userId: string
  ): Promise<CalendarEvent> {
    try {
      const eventsCollection = this.getEventsCollection(workspaceId);
      
      const newEvent = this.cleanEventData({
        ...eventData,
        createdBy: userId,
        createdAt: serverTimestamp(),
        updatedAt: serverTimestamp(),
      });

      const docRef = await addDoc(eventsCollection, newEvent);
      
      // Log activity
      try {
        await ActivityService.logActivity(
          'event_created' as any,
          'calendar',
          docRef.id,
          { 
            title: eventData.title,
            type: eventData.type,
            date: eventData.start.toISOString()
          },
          workspaceId,
          userId
        );
      } catch (error) {
        console.error('Failed to log event creation activity:', error);
      }

      // If it's a recurring event, create future occurrences
      if (eventData.isRecurring && eventData.recurringPattern) {
        await this.createRecurringOccurrences(workspaceId, docRef.id, eventData, userId);
      }

      const createdEvent = await this.getEvent(workspaceId, docRef.id);
      return createdEvent!;
    } catch (error) {
      console.error('Error creating calendar event:', error);
      throw new Error(`Failed to create calendar event: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
  }

  // Get calendar event by ID
  static async getEvent(workspaceId: string, eventId: string): Promise<CalendarEvent | null> {
    try {
      const eventDoc = this.getEventDoc(workspaceId, eventId);
      const docSnap = await getDoc(eventDoc);
      
      if (!docSnap.exists()) {
        return null;
      }
      
      const data = docSnap.data();
      return {
        id: docSnap.id,
        ...data,
        start: data.start?.toDate() || new Date(),
        end: data.end?.toDate(),
        createdAt: data.createdAt?.toDate() || new Date(),
        updatedAt: data.updatedAt?.toDate() || new Date(),
        recurringPattern: data.recurringPattern ? {
          ...data.recurringPattern,
          endDate: data.recurringPattern.endDate?.toDate()
        } : undefined
      } as CalendarEvent;
    } catch (error) {
      console.error('Error getting calendar event:', error);
      throw new Error(`Failed to get calendar event: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
  }

  // Get events for a specific date range
  static async getEvents(
    workspaceId: string,
    startDate: Date,
    endDate: Date,
    filters?: Partial<CalendarFilters>,
    userRole?: 'member' | 'admin' | 'owner'
  ): Promise<CalendarEvent[]> {
    try {
      const eventsCollection = this.getEventsCollection(workspaceId);
      
      let q = query(
        eventsCollection,
        where('start', '>=', Timestamp.fromDate(startDate)),
        where('start', '<=', Timestamp.fromDate(endDate)),
        orderBy('start', 'asc')
      );

      const querySnapshot = await getDocs(q);
      
      let events = querySnapshot.docs.map(doc => {
        const data = doc.data();
        return {
          id: doc.id,
          ...data,
          start: data.start?.toDate() || new Date(),
          end: data.end?.toDate(),
          createdAt: data.createdAt?.toDate() || new Date(),
          updatedAt: data.updatedAt?.toDate() || new Date(),
          recurringPattern: data.recurringPattern ? {
            ...data.recurringPattern,
            endDate: data.recurringPattern.endDate?.toDate()
          } : undefined
        } as CalendarEvent;
      });

      // Apply filters
      if (filters) {
        events = this.applyFilters(events, filters);
      }

      // Apply role-based filtering
      if (userRole === 'member') {
        // Members can only see public events and events they created or are invited to
        events = events.filter(event => 
          event.type !== 'deadline' || 
          event.createdBy === filters?.searchTerm || 
          event.attendees?.includes(filters?.searchTerm || '')
        );
      }

      return events;
    } catch (error) {
      console.error('Error getting calendar events:', error);
      throw new Error(`Failed to get calendar events: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
  }

  // Get report deadlines and create calendar events
  static async getReportDeadlines(
    workspaceId: string,
    startDate: Date,
    endDate: Date
  ): Promise<ReportDeadline[]> {
    try {
      // Get all active report templates
      const ReportTemplateServiceInstance = await getReportTemplateService();
      const templates = await ReportTemplateServiceInstance.getWorkspaceTemplates(workspaceId);
      
      const deadlines: ReportDeadline[] = [];
      
      for (const template of templates) {
        if (template.status === 'active' && template.deadlineConfig) {
          const templateDeadlines = this.generateDeadlinesFromTemplate(
            template,
            startDate,
            endDate,
            workspaceId
          );
          deadlines.push(...templateDeadlines);
        }
      }

      return deadlines;
    } catch (error) {
      console.error('Error getting report deadlines:', error);
      throw new Error(`Failed to get report deadlines: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
  }

  // Update calendar event
  static async updateEvent(
    workspaceId: string,
    eventId: string,
    updates: Partial<CalendarEvent>,
    userId: string
  ): Promise<void> {
    try {
      const eventDoc = this.getEventDoc(workspaceId, eventId);
      
      const updateData = this.cleanEventData({
        ...updates,
        updatedAt: serverTimestamp(),
        start: updates.start ? Timestamp.fromDate(updates.start) : undefined,
        end: updates.end ? Timestamp.fromDate(updates.end) : undefined,
      });

      await updateDoc(eventDoc, updateData);

      // Log activity
      try {
        await ActivityService.logActivity(
          'event_updated' as any,
          'calendar',
          eventId,
          { 
            title: updates.title || 'Event',
            changes: Object.keys(updates)
          },
          workspaceId,
          userId
        );
      } catch (error) {
        console.error('Failed to log event update activity:', error);
      }
    } catch (error) {
      console.error('Error updating calendar event:', error);
      throw new Error(`Failed to update calendar event: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
  }

  // Delete calendar event
  static async deleteEvent(workspaceId: string, eventId: string, userId: string): Promise<void> {
    try {
      const event = await this.getEvent(workspaceId, eventId);
      if (!event) {
        throw new Error('Event not found');
      }

      const eventDoc = this.getEventDoc(workspaceId, eventId);
      await deleteDoc(eventDoc);

      // Log activity
      try {
        await ActivityService.logActivity(
          'event_deleted' as any,
          'calendar',
          eventId,
          { 
            title: event.title,
            type: event.type
          },
          workspaceId,
          userId
        );
      } catch (error) {
        console.error('Failed to log event deletion activity:', error);
      }
    } catch (error) {
      console.error('Error deleting calendar event:', error);
      throw new Error(`Failed to delete calendar event: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
  }

  // Get upcoming events for dashboard
  static async getUpcomingEvents(
    workspaceId: string,
    userId: string,
    days: number = 7,
    limitCount: number = 10
  ): Promise<CalendarEvent[]> {
    try {
      // Use broader date range to find events that might be in future years
      const startDate = new Date();
      const endDate = new Date();
      endDate.setFullYear(endDate.getFullYear() + 2); // Search up to 2 years in future

      const events = await this.getEvents(workspaceId, startDate, endDate);
      
      // Filter events for the user and sort by date
      const userEvents = events
        .filter(event =>
        event.createdBy === userId ||
        event.attendees?.includes(userId) ||
        event.type === 'deadline'
        )
        .sort((a, b) => a.start.getTime() - b.start.getTime());

      // Take only the next upcoming events (within reasonable timeframe)
      const now = new Date();
      const filteredEvents = userEvents.filter(event => event.start >= now);

      return filteredEvents.slice(0, limitCount);
    } catch (error) {
      console.error('Error getting upcoming events:', error);
      throw new Error(`Failed to get upcoming events: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
  }

  // Create recurring event occurrences
  private static async createRecurringOccurrences(
    workspaceId: string,
    parentEventId: string,
    eventData: Omit<CalendarEvent, 'id' | 'createdAt' | 'updatedAt'>,
    userId: string
  ): Promise<void> {
    if (!eventData.recurringPattern) return;

    const pattern = eventData.recurringPattern;
    const occurrences: Date[] = [];
    let currentDate = new Date(eventData.start);
    
    // Generate up to 100 occurrences or until end date
    for (let i = 1; i < 100; i++) {
      const nextDate = new Date(currentDate);
      
      switch (pattern.frequency) {
        case 'daily':
          nextDate.setDate(nextDate.getDate() + pattern.interval);
          break;
        case 'weekly':
          nextDate.setDate(nextDate.getDate() + (pattern.interval * 7));
          break;
        case 'monthly':
          nextDate.setMonth(nextDate.getMonth() + pattern.interval);
          break;
        case 'yearly':
          nextDate.setFullYear(nextDate.getFullYear() + pattern.interval);
          break;
      }

      if (pattern.endDate && nextDate > pattern.endDate) break;
      if (pattern.occurrences && i >= pattern.occurrences) break;

      occurrences.push(new Date(nextDate));
      currentDate = nextDate;
    }

    // Create occurrence events
    const eventsCollection = this.getEventsCollection(workspaceId);
    for (const occurrenceDate of occurrences) {
      const duration = eventData.end ? 
        eventData.end.getTime() - eventData.start.getTime() : 0;
      
      const occurrenceEnd = duration > 0 ? 
        new Date(occurrenceDate.getTime() + duration) : undefined;

      await addDoc(eventsCollection, this.cleanEventData({
        ...eventData,
        createdBy: userId,
        start: Timestamp.fromDate(occurrenceDate),
        end: occurrenceEnd ? Timestamp.fromDate(occurrenceEnd) : undefined,
        relatedId: parentEventId,
        isRecurring: false, // Mark as non-recurring to avoid infinite loop
        createdAt: serverTimestamp(),
        updatedAt: serverTimestamp(),
      }));
    }
  }

  // Generate deadlines from report template
  private static generateDeadlinesFromTemplate(
    template: any,
    startDate: Date,
    endDate: Date,
    workspaceId: string
  ): ReportDeadline[] {
    const deadlines: ReportDeadline[] = [];
    const config = template.deadlineConfig;
    
    if (!config) return deadlines;

    let currentDate = new Date(Math.max(startDate.getTime(), new Date().getTime()));
    
    while (currentDate <= endDate) {
      const deadline: ReportDeadline = {
        id: `deadline-${template.id}-${currentDate.getTime()}`,
        title: `${template.name} - Deadline`,
        description: template.description,
        start: new Date(currentDate),
        allDay: true,
        type: 'deadline',
        status: 'scheduled',
        priority: config.priority || 'medium',
        createdBy: 'system',
        workspaceId,
        templateId: template.id,
        templateName: template.name,
        autoGenerated: true,
        createdAt: new Date(),
        updatedAt: new Date(),
        relatedId: template.id,
        notes: `Recurring deadline for ${template.name}`,
      };

      deadlines.push(deadline);

      // Calculate next deadline based on frequency
      switch (config.frequency) {
        case 'weekly':
          currentDate.setDate(currentDate.getDate() + 7);
          break;
        case 'monthly':
          currentDate.setMonth(currentDate.getMonth() + 1);
          break;
        case 'quarterly':
          currentDate.setMonth(currentDate.getMonth() + 3);
          break;
        case 'yearly':
          currentDate.setFullYear(currentDate.getFullYear() + 1);
          break;
        default:
          return deadlines; // Stop if unknown frequency
      }
    }

    return deadlines;
  }

  // Apply filters to events
  private static applyFilters(events: CalendarEvent[], filters: Partial<CalendarFilters>): CalendarEvent[] {
    let filtered = [...events];

    if (filters.types && filters.types.length > 0) {
      filtered = filtered.filter(event => filters.types!.includes(event.type));
    }

    if (filters.status && filters.status.length > 0) {
      filtered = filtered.filter(event => filters.status!.includes(event.status));
    }

    if (filters.priority && filters.priority.length > 0) {
      filtered = filtered.filter(event => filters.priority!.includes(event.priority));
    }

    if (filters.searchTerm) {
      const searchLower = filters.searchTerm.toLowerCase();
      filtered = filtered.filter(event =>
        event.title.toLowerCase().includes(searchLower) ||
        event.description?.toLowerCase().includes(searchLower) ||
        event.location?.toLowerCase().includes(searchLower)
      );
    }

    if (filters.teams && filters.teams.length > 0) {
      filtered = filtered.filter(event => 
        event.teamId && filters.teams!.includes(event.teamId)
      );
    }

    if (filters.departments && filters.departments.length > 0) {
      filtered = filtered.filter(event => 
        event.departmentId && filters.departments!.includes(event.departmentId)
      );
    }

    return filtered;
  }

  // Get calendar statistics for dashboard
  static async getCalendarStats(workspaceId: string, userId: string): Promise<{
    todayEvents: number;
    weekEvents: number;
    pendingDeadlines: number;
    completedThisWeek: number;
  }> {
    try {
      const now = new Date();
      
      // Set up proper date ranges
      const todayStart = new Date(now.getFullYear(), now.getMonth(), now.getDate(), 0, 0, 0, 0);
      const todayEnd = new Date(now.getFullYear(), now.getMonth(), now.getDate(), 23, 59, 59, 999);
      
      const weekStart = new Date(now);
      weekStart.setDate(now.getDate() - now.getDay());
      weekStart.setHours(0, 0, 0, 0);
      
      const weekEnd = new Date(weekStart);
      weekEnd.setDate(weekStart.getDate() + 6);
      weekEnd.setHours(23, 59, 59, 999);

      console.log('📊 Stats calculation:', {
        todayStart: todayStart.toISOString(),
        todayEnd: todayEnd.toISOString(),
        weekStart: weekStart.toISOString(),
        weekEnd: weekEnd.toISOString()
      });

      const [todayEvents, weekEvents] = await Promise.all([
        this.getEvents(workspaceId, todayStart, todayEnd),
        this.getEvents(workspaceId, weekStart, weekEnd)
      ]);

      console.log('📊 Events found:', {
        todayEvents: todayEvents.length,
        weekEvents: weekEvents.length,
        todayEventsList: todayEvents.map(e => ({ title: e.title, start: e.start.toISOString() })),
        weekEventsList: weekEvents.map(e => ({ title: e.title, type: e.type, status: e.status, start: e.start.toISOString() }))
      });

      // Pending deadlines - only deadline type events that are scheduled/pending
      const pendingDeadlines = weekEvents.filter(event => 
        event.type === 'deadline' && (event.status === 'scheduled' || event.status === 'pending')
      ).length;

      // Completed events this week
      const completedThisWeek = weekEvents.filter(event => 
        event.status === 'completed'
      ).length;

      console.log('📊 Stats breakdown:', {
        pendingDeadlines,
        completedThisWeek,
        deadlineEvents: weekEvents.filter(event => event.type === 'deadline').map(e => ({ title: e.title, type: e.type, status: e.status })),
        pendingDeadlineEvents: weekEvents.filter(event => 
          event.type === 'deadline' && (event.status === 'scheduled' || event.status === 'pending')
        ).map(e => ({ title: e.title, type: e.type, status: e.status })),
        completedEvents: weekEvents.filter(event => 
          event.status === 'completed'
        ).map(e => ({ title: e.title, type: e.type, status: e.status })),
        allWeekEvents: weekEvents.map(e => ({ title: e.title, type: e.type, status: e.status }))
      });

      return {
        todayEvents: todayEvents.length,
        weekEvents: weekEvents.length,
        pendingDeadlines,
        completedThisWeek
      };
    } catch (error) {
      console.error('Error getting calendar stats:', error);
      return {
        todayEvents: 0,
        weekEvents: 0,
        pendingDeadlines: 0,
        completedThisWeek: 0
      };
    }
  }

  // Get report deadline statistics
  static async getReportDeadlineStats(workspaceId: string): Promise<{
    dueToday: number;
    dueThisWeek: number;
    overdue: number;
    submitted: number;
  }> {
    try {
      const today = new Date();
      const weekStart = new Date(today);
      weekStart.setDate(today.getDate() - today.getDay());
      const weekEnd = new Date(weekStart);
      weekEnd.setDate(weekStart.getDate() + 6);
      
      // Get report deadlines for analysis
      const monthStart = new Date(today.getFullYear(), today.getMonth(), 1);
      const monthEnd = new Date(today.getFullYear(), today.getMonth() + 1, 0);
      
      const reportDeadlines = await this.getReportDeadlines(workspaceId, monthStart, monthEnd);
      
      // Calculate statistics
      const dueToday = reportDeadlines.filter(deadline => {
        const deadlineDate = new Date(deadline.start);
        return deadlineDate.toDateString() === today.toDateString();
      }).length;

      const dueThisWeek = reportDeadlines.filter(deadline => {
        const deadlineDate = new Date(deadline.start);
        return deadlineDate >= weekStart && deadlineDate <= weekEnd;
      }).length;

      const overdue = reportDeadlines.filter(deadline => {
        const deadlineDate = new Date(deadline.start);
        return deadlineDate < today && deadline.status === 'scheduled';
      }).length;

      // Get actual submitted reports count for this week
      const ReportServiceInstance = await getReportService();
      const [userReports, workspaceReports] = await Promise.all([
        ReportServiceInstance.getUserReports(workspaceId, '', {
          status: 'submitted',
          dateRange: { start: weekStart, end: weekEnd }
        }).catch(() => []),
        ReportServiceInstance.getWorkspaceReports(workspaceId, {
          status: 'submitted',
          dateRange: { start: weekStart, end: weekEnd }
        }).catch(() => [])
      ]);
      
      // Combine and deduplicate reports to get total submitted count
      const allSubmittedReports = [...userReports, ...workspaceReports];
      const uniqueSubmittedReports = allSubmittedReports.filter((report, index, self) => 
        index === self.findIndex(r => r.id === report.id)
      );
      const submitted = uniqueSubmittedReports.length;

      return {
        dueToday,
        dueThisWeek,
        overdue,
        submitted
      };
    } catch (error) {
      console.error('Error getting report deadline stats:', error);
      return {
        dueToday: 0,
        dueThisWeek: 0,
        overdue: 0,
        submitted: 0
      };
    }
  }
} 